
% return S-polynomial of f and g
procedure spoly(f, g);
  begin scalar mvf, mvg;
    mvf := mainvar(f);
    mvg := mainvar(g);
    ltf := lterm(f, mvf);
    ltg := lterm(g, mvg);
    lcmlt := lcm(ltf, ltg);
    uf := lcmlt / ltf;
    ug := lcmlt / ltg;
    return uf * f - ug * g;
  end;

% perform one reduction of f with g
procedure reduce_poly_step(f, g);
  begin scalar mvf, mvg;
    mvf := mainvar(f);
    mvg := mainvar(g);
    ltg := lterm(g, mvg);
    for each c in coeff(f, mvf) do
      if not (c = 0) and mod(c*mvf, ltg) = 0 then
        begin;
          write(c*mvf, " ", ltg, " ", mvf, " ", c);
          f := f - g*(c*mvf / ltg);
          return f;
        end;
    return f;
  end;


procedure buchberger(F);
  begin;
    G := F;
    P :=
    while length(P) > 0 do
    begin;
      p  := first(P);
      P  := rest(P);
      nf := reduce_poly(p, G);
      if not (nf = 0) then
      begin;
        append(G, {nf});

      end;
    end;

    return G;
  end;

;END;
